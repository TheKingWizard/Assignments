'''
Nov 26, 2019
King Ma

Let's read some images
and their bounding boxes and class type from an xml file. Saves to csv file also (line 89)
#####modified for multiple objects in file

Requirements:
pip install pillow xmltodict

#please change the variables "image_path, annotation_path" to the location of the "Images" and "Annotations" directory.
#I have included a sample 2 images/xml files for demonstration.

#NOTE: going through all images and appending to "images" list may consume more memory, this code is MAINLY to demonstrate
#how to read a couple of images and mainly how to read xml files for the labels.

#Reading all the xml files is fine though, since it is just text.

#use any technique or processing to obtain a classifier on these images/subimages of objects
'''
from PIL import Image
import numpy as np
from matplotlib import pyplot as plt

import glob
import pandas as pd
import xml.etree.ElementTree as ET

##lets read an image.
input_dim = 800  #we don't have to resize unless memory constraint. Class type would remain same but location changes.

images = []
#find all jpg images in this folder
image_paths = glob.glob( 'C:/Users/More/PycharmProjects/Datamining_Project/Images/*.jpg' )
for imagefile in image_paths:
    image = Image.open( imagefile ).resize( ( input_dim , input_dim ))
    image = np.asarray( image ) / 255.0
    images.append( image )
    plt.imshow(image)
    plt.show()
print('image read successful')


##read bounding boxes
def xml_to_csv(path):
    """Iterates through all .xml files (generated by labelImg) in a given directory and combines them in a single Pandas datagrame.

    Parameters:
    ----------
    path : {str}
        The path containing the .xml files
    Returns
    -------
    Pandas DataFrame
        The produced dataframe
    """
    classlist = ['ship','vehicle','airplane']
    xml_list = []
    for xml_file in glob.glob(path + '/*.xml'):
        tree = ET.parse(xml_file)
        root = tree.getroot()
        for member in root.findall('object'):
            #print(member.find('bndbox')[0].text)  #we get ymin xmin ymax x min
            if any (x in member.find('name').text for x in classlist):
            #member[0] is name..but thats only if the name is directly under <object>
                value = (root.find('filename').text,
                        int(root.find('size')[0].text),
                        int(root.find('size')[1].text),
                        member.find('name').text,
                        int(member.find('bndbox')[0].text),
                        int(member.find('bndbox')[1].text),
                        int(member.find('bndbox')[2].text),
                        int(member.find('bndbox')[3].text)
                        )
                xml_list.append(value)
    column_name = ['filename', 'width', 'height',
                'class', 'xmin', 'ymin', 'xmax', 'ymax']
    xml_df = pd.DataFrame(xml_list, columns=column_name)
    return xml_df

###get the dataframe and output it.
annotation_path = 'C:/Users/More/PycharmProjects/Datamining_Project/Annotations'
xml_dataframe = xml_to_csv(annotation_path)
#with mutiple objects so maybe same filename (of image) may have multiple rows.
#print(xml_dataframe['filename'])

#put it to csv file
xml_dataframe.to_csv('sample_labels.csv')

#if you are more comfortable working with pandas, go ahead.
xml_dataframe = xml_dataframe.to_numpy()
###So we can work with this array of images and labels.
imagedatabase = np.array(images)
imagenames = xml_dataframe[0]
object_location = xml_dataframe[4:8]
object_classes = xml_dataframe[3]


#lets show it using opencv.
import cv2
firstimg = images[0]
#better to search matching = 0008.jpg probably...
for i in range(0,xml_dataframe.shape[0]):
 print(xml_dataframe[i])
 if xml_dataframe[i,0]=='00008.jpg':
  single_object = xml_dataframe[i]
  print('filename, width, height:', single_object[0:3])
  print('object class:', single_object[3]) #class
  print('bounding box', single_object[4:8])
  bb0_pred = single_object[4:8]
#we could colorcode each object instead of (255,255,255)
  cv2.rectangle(firstimg, (bb0_pred[0], bb0_pred[1]), (bb0_pred[2], bb0_pred[3]), (255, 255, 255), 2)  # predictions
cv2.imshow("Image", firstimg)
cv2.waitKey(0)

#might need to change your display depending how the width and height (x,y axis) are interpreted.
# cv2.rectangle(firstimg, (bb0_pred[1], bb0_pred[0]), (bb0_pred[3], bb0_pred[2]), (255, 255, 255), 2)  # predictions


#you can convert labels to numbers with dictionary
#then your database is:
print('image dataset size', np.array(images).shape)
print('image label names', imagenames)
print('object list', object_classes)
print('locations', object_location)

#use any technique or processing to obtain a classifier on these images/subimages of objects
